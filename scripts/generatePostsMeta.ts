import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import type { PostMeta } from '../app/blog/types';

const POSTS_DIR = path.join(process.cwd(), 'app/posts');
const META_FILE = path.join(process.cwd(), 'app/postsMeta.ts');

function validateMeta(meta: any, slug: string): PostMeta {
  const required = ['title', 'date', 'readTime', 'excerpt'];
  for (const key of required) {
    if (!meta[key] || typeof meta[key] !== 'string' || !meta[key].trim()) {
      throw new Error(`Post '${slug}' is missing required frontmatter: '${key}'`);
    }
  }
  return meta as PostMeta;
}

function main() {
  const files = fs.readdirSync(POSTS_DIR).filter((f: string) => f.endsWith('.mdx'));
  const metaObj: Record<string, PostMeta> = {};
  for (const file of files) {
    const slug = file.replace(/\.mdx$/, '');
    const fullPath = path.join(POSTS_DIR, file);
    const raw = fs.readFileSync(fullPath, 'utf8');
    const { data } = matter(raw);
    metaObj[slug] = validateMeta(data, slug);
  }
  const metaStr =
    `// AUTO-GENERATED by scripts/generatePostsMeta.ts. DO NOT EDIT.\n` +
    `import type { PostMeta } from './types';\n\n` +
    `export const postsMeta: Record<string, PostMeta> = ` + JSON.stringify(metaObj, null, 2) + ';\n';
  fs.writeFileSync(META_FILE, metaStr, 'utf8');
  console.log(`postsMeta.ts generated with ${files.length} posts.`);
}

main();
